# バージョン管理とGit、GitHub、プルリクエスト

## 概要

いきなりですが、初回はバージョン管理についてお話します。
単なる道具という見方もあるかもしれませんが、
エディタと並んでプログラムを書く人間が知っておくべき重要な道具であり、
たとえプログラムを直接書かない立場になっても開発マネジメント等に使う道具です。
大学でプログラミングを学んでも、その道具として学ぶことはあまりなく、
使ったことがない人もいます。
まずは全体感や考え方をお話し、その上でハンズオンで手を動かします。

### 本日お話すること

* 何のためにバージョン管理するのか？
* バージョン管理とバックアップの違い
* バージョン管理に関わる用語
* バージョン管理の流れ
* その他知っておきたい考え方
  * 何をバージョン管理対象とすべきか？
  * いつからバージョン管理すべきか？
  * コミットログにはどんなことを書けばいいのか？
  * コミットログの書き方の工夫
  * 一時的に変更を戻したい
  * パスワードをコミットしてしまった場合など、過去を改変したい場合は
* おまけ：Gitのデータ構造
  * ハッシュ
  * ブロックチェーンのデータ構造との類似性
  * 設計上の得意・不得意


## バージョン管理を一言でいうと？

適当なタイミングで一連のファイルのスナップショットを変更履歴として残す、
という作業を継続的に行い、あとから履歴の俯瞰や探索ができるようにすること。

## 何のためにバージョン管理するのか？

バージョン管理をすると、次のようなことが可能になる。
本格的な開発においては次のようなことをしたいため、バージョン管理するともいえる。

* プログラムを書いているときに、どこをどのように変更したか簡単に確認できる
  * 必要に応じて、元々のバージョンに戻せる
* 一つのプログラムの様々な部分を他人と同時並行で開発できる
* 他人と開発するときに、自分の行った変更が適切かを他人にチェックしてもらえる
* どのような意図でどのようにプログラムを変更したか、後から履歴を俯瞰できる
* 変更後に問題が見つかった場合、その問題のある変更がいつ入ったのかがわかる
* リリースしたすべてのバージョンの運用システムのソースコードを参照できる
* 機能開発中にバグを見つけたときに、一旦開発の手を止めてまずバグ修正だけを済ませ、また開発に戻れる

一旦バージョン管理に慣れてしまうと、バージョン管理せずにプログラムを書くことが怖くなる。
開発チームの中で、たとえプログラムをあまり書かずコードレビューしかしない立ち位置であっても、
バージョン管理は使えたほうがよい。

##### 考えてみよう！

100行のプログラムならまだいい。
先輩たちが作った、1000行のファイル20個、つまり合計20000行のソースコードから成るプロジェクトに、新たな機能を加えることになった。
お客さんのメールアドレスや社名の他に、住所も登録できるようにしたいとする。
入力欄に住所を加えないといけないし、データベースにも住所の項目を作らないといけない。
表示欄も変更が必要。
そんなときに、バージョン管理なしで開発できるだろうか……？


## バージョン管理とバックアップの違い

バージョン管理はバックアップとしても使えるが、両者は少し違う。

* バックアップ
  * 目的：
    * システムが物理的に壊れたときに復元・復旧できるようにする。
    * 大きな変更により予想外の結果になってしまったときに、復元・復旧できるようにする。
  * 手法：
    * 定期的に自動的に対象全体のスナップショットに時刻の名前をつけて保存する。
    * or 手動で対象全体のスナップショットを保存する。
* バージョン管理
  * 目的：
    * あとから変更内容を俯瞰する。
    * あとから変更内容を探す
  * 手法：
    * 論理的にまとまった変更が終わったときに、その変更内容 (what) を、説明文 (why) と時刻 (when) と一緒に保存する
* 違い
  * バックアップは主に時間単位で管理し、復元を支援する
  * バージョン管理は主に論理的な変更の単位で管理し、変更履歴の俯瞰や探索を支援する

## バージョン管理に関わる用語

バージョン管理に関わる用語。
厳密にはGitの用語。Git以外でもほぼ共通のはず。

### 基本的なもの

* リポジトリ
  過去の履歴の収まったデータベース。
* コミット
  変更内容をデータベースに登録すること、あるいは登録されたスナップショット（前のスナップショットとの間で変更されていないファイルもすべて含めて）。
* コミットログ（コミットメッセージ）
  コミットにつける説明文。
* チェックアウト
  リポジトリから特定のコミットを取り出して一連のファイルとして展開すること。
* ブランチ
  途中で分岐していく複数のタイムライン（パラレルワールドみたいなもの）。
* マージ
  複数のブランチを1つのブランチにまとめること。
* タグ
  リリースなどを特定できるよう、特定のコミットにつけたラベル。

### 他人のリポジトリとのやりとりに必要なもの

* プッシュ
  手元のリポジトリでの変更内容を他のリポジトリに押し込むこと
* プル
  手元のリポジトリに他のリポジトリの変更内容を引っ張り込むこと
* プルリクエスト
  プルして！（私の変更内容を取り込んで！）というリクエスト

## バージョン管理の流れ

### ケースA：自分ひとりで開発する場合

1. リポジトリを作る
2. 管理したいファイルを管理対象にしてコミット
3. ファイルの追加や編集をしてコミット
4. 3の繰り返し

場合によってはファイルの名前を変えたり、削除したりするかもしれないけど、
まぁとりあえずはこんな感じ

### ケースB：他人のリポジトリを使う場合

1. クローンする
2. 自分の作業用のブランチを作成する
3. 必要に応じて変更を取り込み、自分のブランチにマージする
4. ファイルの追加や編集をしてコミット
5. 3〜4の繰り返し
6. 変更内容を他人に共有し、プルリクエストを出して、チェックを経て取り込んでもらう
7. 2〜6の繰り返し

### 編集〜コミットの流れをイメージできるように！

いきなり全部はむずかしいので、まずは編集してコミットを！

1. src/hello.pyを編集する
2. git status
3. git diff
4. git add src/hello.py
5. git status
6. git diff
7. git diff --cached
8. git commit -m 'Capitalize the output message'
9. git log

（多分、何回か手を動かさないと慣れないので、手を動かしてみましょう）


## 細かいトピック

### 何をバージョン管理対象とすべきか？

#### 基本方針

* リポジトリ内のもので一通りできるようにする
  * ソースコードのビルド
  * 自動生成プログラムの生成
  * ドキュメントの生成
  * テスト

#### 原則的に管理すべきファイル

* ソースコード
* ドキュメント（のソース）
* 自動生成に使われるファイル
* テストコード
* テストに用いられるデータ

#### 原則的には管理しないでよいファイル

* サードパーティーのプログラム
* 自動生成されるファイル
* 重すぎるデータファイル

PythonとJavaScriptから始めた人々には「自動生成されるファイル」といっても、
最初はあまり実感が湧かないかもしれないけど。。。

#### 特殊ケース：プロジェクトの方針次第

* データサイエンスのプロジェクトでの重いデータの管理
* サードパーティーのプログラムを改変して使っている場合
* 自動生成に使われるソフトウェアのバージョンによって、
  自動生成結果が変わりそうなので、自動生成したものも
  念のため保存したい

#### 特殊ケースの扱い方

* バージョン管理システムに固執せず、
  tarballにまとめて共有ストレージ（Windowsファイル共有、Google Drive、AWS S3、等）
  に置くという選択肢をとる
* 1つのリポジトリに固執せず、別のリポジトリに分けるという選択肢をとる
  * たとえば、GitHub上でサイトを公開している場合、
    ソースはプログラムと一緒に管理、公開用にビルドしたものは別リポジトリ管理、
    としていたりする

### いつからバージョン管理すべきか？

開発初期は、ひたすらプログラムを追加していくのみで、
コードの一部を大きく書き換えたりすることはないはず。
開発初期は「○○を実装」など細かくコミットしているときりがなく、
勢いをもって全体を大まかに作り上げることが重要だと自分は考えるので、
自分は、
**全体の流れが一通り出来上がるか、あるいは特定の機能だけしっかり作った段階**
からきちんとコミットし始める。
もちろん、ソースコードができる前でもドキュメント等があれば、
それらは管理していく。


### どんなコミットをすればよいのか？

#### 基本原則

**「レビューがしやすくなるように」**

他人が見たり、あとで自分が見たときにわかるようにコミットする。
『リーダブルコード』の「読みやすいプログラムを書く」のと同じ考え。

#### 大まかな具体方針

* 「機能Aを追加」「文字化けするバグを修正」など、
  論理的な単位でのコミット ⇒○
* 「今日はここまで」など、
  日付、時間ベースでのコミット ⇒×

後者は、最初に説明したように「バージョン管理」というより「バックアップ」。
「昨日はここまで作ったけど、今日問題点に気づいて全体的に書き直し」とか、
あるよね（長期的にはそういうのはあっても仕方ないけど）。

#### 中途半端なコミットはダメなのか？

中途半端でも、論理的な単位になっていてレビューしやすければよい。

「まずは全体の流れを作成」「機能1を実装」などなら、わかりやすい。

#### コミットする粒度は？

小さすぎず、大きすぎず、がよいと個人的には思う。

小さすぎると、コミットの頻度が高すぎて無駄が多い。
「3行書いた。はいコミット」などとやっていたら、
たぶん時間の1/3くらいはコミットに費やしている。
それに、レビューする人にとっても全体が見えにくい。

大きすぎると、全体は見えやすいけどレビューするのが大変。
10000行の変更をくまなくチェックするのは厳しい。

もっとも、たとえばtypoの修正のようなものなら、1行でも問題ない。
変更すべき箇所がそれしかないのだから仕方がない。

### ファイル全体に渡る変更は？

当然ながら、同じ場所を複数人で変更すると、競合し、お互い不幸になる。
人とかちあう変更は、システムでは解決できないので、人間で調整を。

#### エディタによる変更に注意！

エディタが自動的に行の末尾の空白を削除して、差分が巨大になってしまったりする。
コミット前に、必ず差分をチェックすること。

「コードのフォーマットを全体的に直したい」などは、
別の機会に、全員が足並み揃えてOKなときにやること。

### コミットログにはどんなことを書けばいいのか？

#### "Update foo.py"?

gitというコマンドの使い方を説明しているサイトは巷にあまたあれど、
コミットログにどんなことを書けばよいのかの説明は、あまり見かけない。
巷の例にあるコミットログは「Update foo.py」など一言書かれているだけのものが多い。

「Add foo.py」
「Update foo.py」
は基本的には避けたい。

基本方針：**「差分を見て簡単にわかる（けど背景の理解には繋がらない）ことは書かない」**
* 「どのファイルを変更したか」など

#### whatよりwhyを

プログラムを書くときには、コメントとして、whatよりもwhyを書いたほうがよい。

「何故こんなtrickyなことをしているのか？（使っているライブラリの問題を回避したい、など）」
「何故このテストを追加したのか？（昔のこのバグが再発しないか確認したいので、など）」

同じように、コミットログにもwhyを書いた上げたほうがよい。

#### 長さは？

必要であれば、長くてもOK。

例：
[https://github.com/torvalds/linux/commit/3f36d8669457605910cb7a40089b485949569c41]

ただ、プロジェクトによっては、このような背景情報はGitHubでissueとして管理しているので、
その番号を参照しているだけでもよい。

例：
[https://github.com/pandas-dev/pandas/commit/9d45934af87ce4bdf204836a2e9cfcc3a7e5c279]

#### 複数行に渡るコミットログの書き方

* 1行目：サマリ
  gitでは1行目はメールのSubjectに相当するものとして扱われる。
  （メールで送信できるよう、メールに変換する機能もあり、その場合は1行目がSubjectとして使われる。また、1行目だけをずらずら並べる表示もできる。GitHubでも1行目だけは特別視される）
  なので、1行目だけは次の行に跨がらないほうがよい。

* 2行目：空行
  サマリと本文を分けるため、明示的に空行を入れることが多い。

* 3行目〜：本文


[Pro Git 5章](https://git-scm.com/book/ja/v2/Git-での分散作業-プロジェクトへの貢献)


### コミットログの書き方の工夫

コミットはさまざまな変更が含まれるが、大体いくつかのカテゴリに分けられる。

* 機能追加
* バグ修正
* クリーンアップ（動作への影響はない）
* ドキュメント整備
* テスト追加
* ：

たとえサマリ行だけの表示にしても、大量にコミットがあるときにすべての自然言語を読み解いて
これらのどれに相当するのか頭の中で整理していくのは大変である。
世の中にはこの作業を簡単にするため、コミットログの先頭にそれらを区別する文字を入れているプロジェクトが存在する。

たとえばpandasではこんなコードを頭に入れるルールにしている。

* ENH: Enhancement, new functionality
* BUG: Bug fix
* DOC: Additions/updates to documentation
* TST: Additions/updates to tests
* BLD: Updates to the build process/scripts
* PERF: Performance improvement
* CLN: Code cleanup

XXX: こちらのURLを参照
XXXこちらのコミットログを参照

たとえばatomではこんな絵文字を頭に入れることを検討するよう定めている。

XXX: CONTRIBUTING.md参照
XXXこちらのコミットログを参照

コミットログは、みんながバラバラに書くと乱雑感が出てしまうが、
（日本語/英語、capitalizeする/しない）
ちょっとガイドラインを定めると見やすくなるので、
こういったものを参考に、チームで何かガイドラインを定めてもよいのでは？


### コミットログは英語で書かないといけないのか？

技術的には言語の制約はないので、チーム内のルールに従うのがよい。
文字コードには制約があり、日本語やその他の言語を使う場合、UTF-8にしておくのが無難。

個人的な意見：

* 開発チーム内のコミュニケーションに使う言葉が英語でなければ、
  コミットログを英語で書く必要はない。
* 英語で書いたほうが英語の練習になるとは思う。
* とはいえ、語彙が少なく、書きたいことがうまく表現できずに「Add ...」「Change ...」の
  繰り返しのようになってしまうくらいなら、
  あるいは英語の表現をブラッシュアップするのに時間をかけすぎるくらいなら、
  日本語で書いたほうがよい。


### 一時的に変更をsaveしたい

（省略。。。）

### 以前のコミットを修正したい

* パスワードなどをコミットしてしまった
  （たとえ最新版から消しても、履歴として永久に残る）
* コミットした内容に含まれるtypoなどつまらない修正は、
  他人に見てもらう前にメインのコミットに取り込んでしまい、
  レビューしてもらいやすくしたい
* ファイルの変更はコミットしたが、
  一緒にコミットすべきファイルの追加を忘れていた。
  2つ合わせて変更として意味を成すので、できれば1つにまとめてしまいたい
 
方法は色々ある：

* git reset HEAD~
* git commit --amend
* git rebase -i
* git filter-branch

など、「歴史を改変する」手段は色々とあるけど、最初にいきなり覚えるのは大変だし、
これらのコマンドまで間違えてしまうと対応が大変なので、
慣れたら覚えていきましょう。

[https://qiita.com/muran001/items/dea2bbbaea1260098051]

重要な原則：

* 自分のローカルにしかないコミットであれば、
  いくらでも変更をまとめたりして問題ありません
  むしろ、他人がレビューしやすくするために手直しを推奨します
* 他人にすでに共有した変更については、
  履歴をいじるのは他人にも影響を及ぼすので、
  原則はやらない。やるなら必ず事前に確認して、全員が都合のよいタイミングで行う。
* パスワードなど、履歴に残してはいけないものをコミットしてしまった場合は、
  その限りではない（全員の履歴から削除すべき）。
  強いて言えば、共有（プッシュ、マージ）の前に必ずチェックするべき。


### アドバイスは？

#### 目に見えないものをイメージする

おそらく最初戸惑うのは、次のような、目に見えなものの切り替えのはず：

* ブランチ
* ユーザが実際に目にするファイルと、ステージング、そしてブランチの最新版（`HEAD`）という3つの状態

`git diff`、`git diff --cached`、`git branch`を使って、今自分がどのブランチで何と何の差分を見ているかイメージを持つのが大切。
これらをしっかりと意識できれば、おそらくはすぐに使いこなせる。

#### とにかく遊んでみる

ローカルで勝手にリポジトリを立て、ブランチを切り替え、様々な変更を加える分には誰も迷惑しない。また、GitHubにプッシュしても、プライベートリポジトリであれば社外の人には見えない。所詮普通のファイルなので、要らなくなったらディレクトリごと消せばよい。とにかく遊んで慣れる。


### おまけ：Gitのデータ構造

[https://git-scm.com/book/ja/v2/Gitの内側-Gitオブジェクト]を参照。

Gitは「各ブランチの最新のコミット」のみを知っている。
これがあれば過去や変更内容はすべて辿れる。

#### ハッシュ

データの「指紋」。
どんなデータでも、一瞬で32文字（というより32桁の16進数）で表せる。
他のファイルと「指紋」が被る可能性はゼロではないが、ほぼない。

そのような関数はいくつかあり、Gitでは現在、SHA1というものを使っている。

#### ブロックチェーンのデータ構造との類似性

[https://git-scm.com/book/ja/v2/Gitの内側-Gitオブジェクト]のように、
ハッシュをベースにどんどん過去を辿れるのは、昨日のブロックチェーンのデータ構造と同じ。
違うのは、ブロックチェーンのほうが計算に時間がかかり、より暗号を意識している点。

#### 設計上の得意・不得意

データ構造上、親をどんどんたどっていくかたちになっている。
だから、

* 「自分の子」はわからない。
* ツリー全体の履歴を追うほうが楽。
  特定のファイルの変更だけを追うのは時間がかかる。



## 演習

以下、次のように表す。

* プロジェクトページURL：https://github.com/weathernews/DIT-training-FY34
* プロジェクト名：DIT-training-FY34
* アカウント名：小林の場合なら`koba-n`のこと
* GitHubアカウント名：小林の場合なら`koba-n-wni`のこと


### 準備：GitHubアカウント準備

GitHubのWeathernews organizationにアカウントがない人は作りましょう。

* メールアドレス：`<会社のアドレス>`
* ユーザ名：`<アカウント名>-wni`

1. 上記メールアドレスおよびユーザ名でsign upする
2. 小林にsign upした旨伝える
3. 小林がinviteするのを待つ
4. <プロジェクトページURL>にブラウザでアクセスできるのを確認


### 準備：コミットに入る自分の情報の設定

Gitでは、コミットした人の情報として、コミットにユーザ名とメールアドレスが入ります。
デフォルトだと使っている環境でのユーザ名やホスト名が使われてしまうので、
設定していない人は設定しておきましょう。

1. `git config --global user.name <フルネーム（アルファベット表記）>`
2. `git config --global user.email <会社のメールアドレス>`
3. `cat ~/.gitconfig`

コマンドで設定した内容が`~/.gitconfig`に書き込まれていることがわかる。


### ハンズオン＆演習1：リポジトリのクローンを手元に作成する

1. <プロジェクトページURL>の「Fork」ボタンを押す
2. 自分のプロフィールページの「Repositories」に <プロジェクト名> という名前のページができてリンクが張られていることを確認
3. そのプロジェクトへのリンクに飛ぶ
4. 緑色の「Clone or download」ボタンを押す
5. 出てきたメニューに表示されたURLの右のボタンを押す（とURLがコピーされる）。
6. ターミナルで、適当なディレクトリを作成し、そこに移動。
7. `git clone https://<GitHubアカウント名>@github.com/<GitHubアカウント名>/<プロジェクト名>.git` と実行する （上でコピーしたURLの中に「`<GitHubアカウント名>@`」を挟むのがポイント）。
8. `ls`で、`<プロジェクト名>`というディレクトリができているのを確認（上の`git clone`コマンドで出てきたメッセージの最後が`done.`で終わっていたらおそらくできているはず）。
9. `cd <プロジェクト名>`でディレクトリの中に入っておく。
10. `ls -al`してみる。

`ls -al`で、いくつかファイルがあること、また`.git`というディレクトリがあることがわかるはずです。
`.git`の中身がリポジトリです。それ以外は、リポジトリからチェックアウトされた最新版のファイルです。
`git clone`コマンドでは、リポジトリのクローンを手元に作成するだけでなく、そこから最新のファイルをチェックアウトするところまでやってくれることがわかります。


### ハンズオン＆演習2：ブランチの切り替え、編集〜コミットの流れをやってみる

#### 注意点

* コミットした内容はあとの課題で共有してもらいます
* なので、コミット内容には、不適切な内容、パスワードなどの秘密情報は含めないでください
* GitHubに容量制限があり、実務でもないので、無駄に大きなファイルは入れないでください

#### アドバイス

以降で、`git branch`、`git status`、`git diff`、`git diff --cached`、`git log`は、状態を表示するだけで特に何かを変更するわけではないので、何回でも実行して問題ありません。むしろ、動作に慣れないうちはしょっちゅう実行して確認したほうがよいでしょう。

また、以降の手順で自分のアカウント名のディレクトリを作っているのは、あとの課題で共有してもらうときに、他の人のファイル名と被らないようにするためです。Gitでの操作上、そういうことが必要なわけではありませんので、あくまで課題のためと理解してください。

また、`t01`というディレクトリはトレーニング第1回用のディレクトリという意味で使っています。今後も、同じようにしてディレクトリを増やしていくつもりです。

#### ブランチを作って切り替えてみる

1. `git branch`で、存在するブランチと今いるブランチを確認
2. `git checkout -b work`で、workというブランチを作ってそちらに移動（表面上は何も変わらない）
3. `git branch`で、あらためてブランチを確認（先程の結果と違うはず）

なお、別にworkである必要はありません。複数のブランチを行き来することもあるので、実務ではもっと意味のある名前をつけましょう。

#### 編集してコミットしてみる

1. `cd t01`
2. `mkdir <アカウント名>`（自分のディレクトリを作ってみる）
3. `cp sample0.md <アカウント名>/README.md` （適当な`README.md`を自分のディレクトリの下に作ってみる）
4. `git log` （確認。あとで比較する）
5. `git status` （確認。あとで比較する）
6. `git diff` （確認。既存のファイルには変更はないので空のはず。あとで比較する）
7. `git diff --cached` （確認。同じく空のはず。あとで比較する）
8. `git add <アカウント名>/README.md` （ファイルの追加をステージングに反映させる）
9. `git status` （確認。変化があるはず）
10. `git diff` （確認。こちらは空のままのはず）
11. `git diff --cached` （確認。ステージングなので先程から変化があるはず）
12. `git commit -m 'Add my own README.md'`
13. `git log` （今のコミットが最新コミットとしてログに追加されているだろうか？）
14. `git status` （確認）
15. `git diff` （確認）
16. `git diff --cached` （確認）

#### もっと複雑に編集してコミットしてみる。

1. `cp sample1.md <アカウント名>/README.md` （先程のファイルを上書きする。ここでは簡単のためコピーしているが、`<アカウント名>/README.md`を2箇所編集するのをシミュレートしたつもり）
2. `git status` （確認）
3. `git diff` （確認。差分がファイル内に2箇所あることがわかるはず）
4. `git diff --cached` （確認。こちらは空のはず）
5. `git add -p`
6. `Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]?`という質問を2回尋ねられるので、1回目は`y`、2つ目は`n`と答える（2箇所の差分のうち1箇所目だけをステージングに反映させる）
7. `git status` （確認）
8. `git diff` （確認。2つ目の差分だけのはず）
9. `git diff --cached` （確認。1つ目の差分だけのはず）
10. `git commit -m 'Change the title of my project'`
11. `git log -p` （今のコミットの内容は期待通りか？）
12. `git diff` （確認。2つ目の差分だけのはず）
13. `git diff --cached` （確認。空のはず）
14. `git add <アカウント名>/README.md`
15. `git status` （確認）
16. `git diff` （確認。空のはず）
17. `git diff --cached` （確認。2つ目の差分だけのはず）
18. `git commit -m 'Add one more section to README.md'`
19. `git log -p`

#### ログの表示を色々変えてみる

1. `git log`
2. `git log --oneline`
3. `git log -p`
4. `git log --stat`
5. `git log --graph`

最後の`git log --graph`は、あとで色々マージしたあとに使うと役に立つはず。


### ハンズオン＆演習3：マージしてみる

#### まずはfixブランチでコミット

1. `git checkout -b fix`
2. `git branch` （fixにいるはず）
3. `cp sample2.md <アカウント名>/README.md` （これも、ファイルを編集したのをシミュレートしている）
4. `git diff`
5. `git add <アカウント名>/README.md`
6. `git commit -m 'Fix a typo'`
7. `git log`

#### 続いてworkブランチでコミット

1. `git checkout work` （`-b`オプションは「ブランチを作る」という意味。今回は既存のブランチに移動するだけなので、`-b`はつけない）
2. `git branch` （workにいるはず）
3. `cat <アカウント名>/README.md` （先程fixブランチで行った変更は、こちらには入っていないのがわかる）
4. `cp sample3.md <アカウント名>/README.md` （これも、ファイルを編集したのをシミュレートしている）
5. `git diff`
6. `git add <アカウント名>/README.md`
7. `git commit -m 'Welcome more'`
8. `git log`

#### workブランチにfixブランチをマージ

1. `git merge fix` （現在のworkブランチにfixブランチをマージする）
2. `cat <アカウント名>/README.md` （確認。fixブランチで行った変更が入っているはず）
2. `git log`
3. `git log --graph`
4. `git branch` （確認。あとで比較する）
5. `git branch -d fix` （fixブランチの役割は終わったので削除）
6. `git branch` （確認。fixブランチが消えているはず）

ちなみに、手元にマージしていないブランチを削除しようとすると、エラーになるはず。
ブランチは最終的にマージされるはず、という想定で、そのような安全な作りとなっている。


### ハンズオン＆演習4：自分なりの変更を色々加えてみる

ディレクトリ`t01/<アカウント名>`は今回の課題にしか使わないので、
自由にファイルを追加したり編集を加えて、コミットしてみてください。
最終的にworkブランチにマージしてもらえれば、ブランチも適当に作ってみるとよいです。


### ハンズオン＆演習5：プルリクエストを送ってみる

#### プッシュしてみる

1. `git remote` （確認。おそらく`origin`だけが登録されているはず）
2. `git remote -v` （確認。クローン元のURLが`origin`となっているはず）
3. `git push` （現在のブランチの内容が`origin`へとプッシュされる）
4. 自分のプロフィール内のプロジェクトページ（https://github.com/<GitHubアカウント名>/<プロジェクト名>）を確認（反映されているはず）

#### プルリクエストしてみる

1. 最初の<プロジェクトページURL>を再び開く。
2. 「Pull requests」を開く。

XXX 作成。

正しくプルリクエストを送っていただければ、一応今回の課題完了とします。


### ハンズオン＆演習6：社外のリポジトリを眺めてみる

余裕があったら、社外のリポジトリも手元に`git clone`してみましょう。

先程、`git clone https://<GitHubアカウント名>@github.com/<GitHubアカウント名>/<プロジェクト名>.git`のようにURLに`<GitHubアカウント名>@`と入れましたが、公開されているリポジトリであればこれは不要です（GitHubのプロジェクトページの緑のボタンを押して出てくるURLをそのまま使えばOK）。


### TBC

* macOSでデフォルトで動くエディタ
* Windowsユーザの場合の環境構築
